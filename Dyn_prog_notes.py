def fib1(n):
    global numCalls
    numCalls += 1
    print numCalls
    print 'fib called with',n
    if n <= 1:
        return 1
    else:
        return fib1(n-1) + fib1(n-2)

#numCalls = 0
#n = 6
#res = fib1(n)
#print 'result', res

def fastFib(n, memo):               # store values to lookup in a dictionary to avoid overlapping values generated by recursive calls 
    global numCalls
    numCalls += 1
    print 'fib called with',n
    if n not in memo:
        memo[n] = fastFib(n-1, memo) + fastFib(n-2, memo)
    return memo[n]
def fib2(n):
    memo = {0:1, 1:1}
    return fastFib(n, memo)
#numCalls = 0
#n = 6
#res = fib2(n)
#print 'result',res

#Decision Tree :-
#itemIndex = [0, 1, 2] 
#weights = [5, 3, 2]
#values = [9, 7, 8]
#Max weight in a knapsack = 5
#Iteration and decision starts from the back, depth first. left first; in building the tree.
#Start from (2, 5, 0). where 2 is index, 5 is weight available, 0 is the value
#                            (2, 5, 0)
#                            / \
# "Don't take item at 2"    /   \      "Take item at 2"
#                          /     \
#                         /       \
#                     (1, 5, 0)   (1, 3, 8)
#                     /\           / \  
#                    / (0, 2, 7)  /   \
#                   /  / \       /   (0, 0, 15) 
#                  /  / (can't) (0, 3, 8)        
#                 / (-,2,7)      /   \
#                /             (-,3,8)\
#               (0, 5, 0)   (0, 3, 8)  \
#               / \          / \       (can't)
#              /   \        /   \
#             /     \  (-, 3, 8) \
#            /       \            \
#       (-, 5, 0)  (-, 0, 9)     (can't, weight exceeds)   

def maxVal(w, v, i, aW):
    print 'maxVal called with:',i ,aW
    global numCalls
    numCalls += 1
    if i == 0:
        if w[i] <= aW:
            return v[i]
        else:
            return 0
    without_i = maxVal(w, v, i-1, aW)       # the don't take branch. In don't takes, the only thing changes is index
    if w[i] > aW:
        return without_i            # return 
    else:
        with_i = v[i] + maxVal(w, v, i-1, aW - w[i])
        return max(with_i, without_i)
#weights = [1, 5, 3, 4]
#vals = [15, 10, 9, 5]
#weights = [1, 5, 3, 4, 5, 3, 8, 3, 1, 2, 4, 5, 7, 4, 6, 2, 1]
#vals = [15, 10, 9, 5, 5, 1, 9, 4, 7, 2, 3, 4, 6, 7, 2, 6, 3]
#numCalls = 0
##res = maxVal(weights, vals, len(vals)-1, 8)   
#res = maxVal(weights, vals, len(vals)-1, 20)   
#print 'max val =', res, ', number of calls =',numCalls 


# Faster version of maxVal, works similar to fastFib
def fastMaxVal(w, v, i, aW, memo):    
    global numCalls
    numCalls += 1
    try:
        return memo[(i, aW)]            
    except KeyError:
        if i == 0:
            if w[i] <= aW:
                memo[(i, aW)] = v[i]
                return v[i]
            else:
                memo[(i, aW)] = 0
                return 0
        without_i = fastMaxVal(w, v, i-1, aW, memo)  
        if w[i] > aW:
            memo[(i, aW)] = without_i
            return without_i
        else:
            with_i = v[i] + fastMaxVal(w, v, i-1, aW - w[i], memo)
        res = max(with_i, without_i)
        #print 'after res'
        memo[(i, aW)] = res
        return res

def maxVal0(w, v, i, aW):
    memo = {}
    return fastMaxVal(w, v, i, aW, memo)

weights = [1, 5, 3, 4, 5, 3, 8, 3, 1, 2, 4, 5, 7, 4, 6, 2, 1]
vals = [15, 10, 9, 5, 5, 1, 9, 4, 7, 2, 3, 4, 6, 7, 2, 6, 3]
numCalls = 0
res = maxVal0(weights, vals, len(vals)-1, 20)   
print 'max val =', res, ', number of calls =',numCalls 
        
                  